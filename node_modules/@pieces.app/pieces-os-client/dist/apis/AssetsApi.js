"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsApi = void 0;
const runtime = __importStar(require("../runtime"));
const models_1 = require("../models");
/**
 *
 */
class AssetsApi extends runtime.BaseAPI {
    /**
     * This endpoint will accept a seeded (a structure that comes before an asset, will be used in creation) asset to be uploaded to pieces. Response here will be an Asset that was create!
     * /assets/create [POST] Scoped to Asset
     */
    async assetsCreateNewAssetRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/assets/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.SeedToJSON)(requestParameters.seed),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetFromJSON)(jsonValue));
    }
    /**
     * This endpoint will accept a seeded (a structure that comes before an asset, will be used in creation) asset to be uploaded to pieces. Response here will be an Asset that was create!
     * /assets/create [POST] Scoped to Asset
     */
    async assetsCreateNewAsset(requestParameters) {
        const response = await this.assetsCreateNewAssetRaw(requestParameters);
        return await response.value();
    }
    /**
     * This endpoint will just take a uid to delete out of the assets table, will return the uid that was deleted.
     * /assets/delete [POST] Scoped to Asset
     */
    async assetsDeleteAssetRaw(requestParameters) {
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset', 'Required parameter requestParameters.asset was null or undefined when calling assetsDeleteAsset.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/{asset}/delete`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.TextApiResponse(response);
    }
    /**
     * This endpoint will just take a uid to delete out of the assets table, will return the uid that was deleted.
     * /assets/delete [POST] Scoped to Asset
     */
    async assetsDeleteAsset(requestParameters) {
        const response = await this.assetsDeleteAssetRaw(requestParameters);
        return await response.value();
    }
    /**
     * This is an endpoint that will enable a developer to pass in a Seed and get a seed with preprocessed information on that seed out of this endpoint, nothing is persisted, this is a strict input/output endpoint. and return a drafted asset (seed with some initial information).  for images, we will just return the seed that was passed to us. a TODO for v2 would eb to add preprocessing for images as well.
     * /assets/draft [POST]
     */
    async assetsDraftRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/assets/draft`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.SeedToJSON)(requestParameters.seed),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.SeedFromJSON)(jsonValue));
    }
    /**
     * This is an endpoint that will enable a developer to pass in a Seed and get a seed with preprocessed information on that seed out of this endpoint, nothing is persisted, this is a strict input/output endpoint. and return a drafted asset (seed with some initial information).  for images, we will just return the seed that was passed to us. a TODO for v2 would eb to add preprocessing for images as well.
     * /assets/draft [POST]
     */
    async assetsDraft(requestParameters) {
        const response = await this.assetsDraftRaw(requestParameters);
        return await response.value();
    }
    /**
     * An endpoint that takes in a SeededAssetsRecommendation Model within it\'s request body, which requires an object including assets (Assets Model) as well as interactions (InteractedAssets Model) - the resulting will return an Assets Model for use in a UI.
     * Your GET endpoint
     */
    async assetsGetRecommendedAssetsRaw(requestParameters) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/assets/recommended`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.SeededAssetsRecommendationToJSON)(requestParameters.seededAssetsRecommendation),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetsFromJSON)(jsonValue));
    }
    /**
     * An endpoint that takes in a SeededAssetsRecommendation Model within it\'s request body, which requires an object including assets (Assets Model) as well as interactions (InteractedAssets Model) - the resulting will return an Assets Model for use in a UI.
     * Your GET endpoint
     */
    async assetsGetRecommendedAssets(requestParameters) {
        const response = await this.assetsGetRecommendedAssetsRaw(requestParameters);
        return await response.value();
    }
    /**
     * Gets one or more related assets when provided one or more input assets. The body will expect the shape of
     * /assets/related [GET]
     */
    async assetsGetRelatedAssetsRaw(requestParameters) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/assets/related`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.AssetsToJSON)(requestParameters.assets),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetsFromJSON)(jsonValue));
    }
    /**
     * Gets one or more related assets when provided one or more input assets. The body will expect the shape of
     * /assets/related [GET]
     */
    async assetsGetRelatedAssets(requestParameters) {
        const response = await this.assetsGetRelatedAssetsRaw(requestParameters);
        return await response.value();
    }
    /**
     * This will get all of your asset ids
     * /assets/identifiers [GET]
     */
    async assetsIdentifiersSnapshotRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/identifiers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.FlattenedAssetsFromJSON)(jsonValue));
    }
    /**
     * This will get all of your asset ids
     * /assets/identifiers [GET]
     */
    async assetsIdentifiersSnapshot(requestParameters) {
        const response = await this.assetsIdentifiersSnapshotRaw(requestParameters);
        return await response.value();
    }
    /**
     * This will get a snapshot of ONLY the pseudo Assets included in your Pieces drive.
     * /assets/pseudo [GET]
     */
    async assetsPseudoSnapshotRaw() {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/pseudo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.PseudoAssetsFromJSON)(jsonValue));
    }
    /**
     * This will get a snapshot of ONLY the pseudo Assets included in your Pieces drive.
     * /assets/pseudo [GET]
     */
    async assetsPseudoSnapshot() {
        const response = await this.assetsPseudoSnapshotRaw();
        return await response.value();
    }
    /**
     * This function will search your pieces and will return Assets(the results) based on your query! Eventually** /assets/search?query=string [GET] Scoped to Asset  Currently just send along your query in the body.  Required to pass searchable_tags (csv of tags) or a query string.  if a query is passed we will run through fuzzy search.  if searchable_tags are passed we will run through tag_based_search.  if neither are passed in we will return a 500.
     * /assets/search?query=string [GET]
     */
    async assetsSearchAssetsRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        if (requestParameters.searchableTags !== undefined) {
            queryParameters['searchable_tags'] = requestParameters.searchableTags;
        }
        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.SearchedAssetsFromJSON)(jsonValue));
    }
    /**
     * This function will search your pieces and will return Assets(the results) based on your query! Eventually** /assets/search?query=string [GET] Scoped to Asset  Currently just send along your query in the body.  Required to pass searchable_tags (csv of tags) or a query string.  if a query is passed we will run through fuzzy search.  if searchable_tags are passed we will run through tag_based_search.  if neither are passed in we will return a 500.
     * /assets/search?query=string [GET]
     */
    async assetsSearchAssets(requestParameters) {
        const response = await this.assetsSearchAssetsRaw(requestParameters);
        return await response.value();
    }
    /**
     * This function will search your pieces and will return Assets(the results) based on your query! /assets/search [POST] Scoped to Asset  Currently just send along your query in the body.  if a query is passed we will run through fuzzy search.  The Post Body will also accept a search space, being either a list of uuids.(in the future potentially Seeds.) The Post Body will also accept optional filters, which is an iterable of filters all will be AND operations for now.
     * /assets/search [POST]
     */
    async assetsSearchWithFiltersRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/assets/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.AssetsSearchWithFiltersInputToJSON)(requestParameters.assetsSearchWithFiltersInput),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetsSearchWithFiltersOutputFromJSON)(jsonValue));
    }
    /**
     * This function will search your pieces and will return Assets(the results) based on your query! /assets/search [POST] Scoped to Asset  Currently just send along your query in the body.  if a query is passed we will run through fuzzy search.  The Post Body will also accept a search space, being either a list of uuids.(in the future potentially Seeds.) The Post Body will also accept optional filters, which is an iterable of filters all will be AND operations for now.
     * /assets/search [POST]
     */
    async assetsSearchWithFilters(requestParameters) {
        const response = await this.assetsSearchWithFiltersRaw(requestParameters);
        return await response.value();
    }
    /**
     * Get all of the users Assets.
     * /assets [GET] Scoped to Assets
     */
    async assetsSnapshotRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        if (requestParameters.suggested !== undefined) {
            queryParameters['suggested'] = requestParameters.suggested;
        }
        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/assets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetsFromJSON)(jsonValue));
    }
    /**
     * Get all of the users Assets.
     * /assets [GET] Scoped to Assets
     */
    async assetsSnapshot(requestParameters) {
        const response = await this.assetsSnapshotRaw(requestParameters);
        return await response.value();
    }
    /**
     * This will query the formats for agiven asset when provided that asset\'s id.
     * /assets/{asset}/formats [GET] Scoped To Assets
     */
    async assetsSpecificAssetFormatsSnapshotRaw(requestParameters) {
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset', 'Required parameter requestParameters.asset was null or undefined when calling assetsSpecificAssetFormatsSnapshot.');
        }
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/{asset}/formats`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.FormatsFromJSON)(jsonValue));
    }
    /**
     * This will query the formats for agiven asset when provided that asset\'s id.
     * /assets/{asset}/formats [GET] Scoped To Assets
     */
    async assetsSpecificAssetFormatsSnapshot(requestParameters) {
        const response = await this.assetsSpecificAssetFormatsSnapshotRaw(requestParameters);
        return await response.value();
    }
    /**
     * This is an endpoint to enable a client to access a specific asset through a provided uuid in the path.
     * /assets/{asset} [GET] Scoped to Assets
     */
    async assetsSpecificAssetSnapshotRaw(requestParameters) {
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset', 'Required parameter requestParameters.asset was null or undefined when calling assetsSpecificAssetSnapshot.');
        }
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/{asset}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetFromJSON)(jsonValue));
    }
    /**
     * This is an endpoint to enable a client to access a specific asset through a provided uuid in the path.
     * /assets/{asset} [GET] Scoped to Assets
     */
    async assetsSpecificAssetSnapshot(requestParameters) {
        const response = await this.assetsSpecificAssetSnapshotRaw(requestParameters);
        return await response.value();
    }
    /**
     * This will stream the asset identifiers(uuids) that have changed via a websocket connection.
     * /assets/stream/identifiers [GET]
     */
    async assetsStreamIdentifiersRaw() {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/stream/identifiers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.StreamedIdentifiersFromJSON)(jsonValue));
    }
    /**
     * This will stream the asset identifiers(uuids) that have changed via a websocket connection.
     * /assets/stream/identifiers [GET]
     */
    async assetsStreamIdentifiers() {
        const response = await this.assetsStreamIdentifiersRaw();
        return await response.value();
    }
    /**
     * This will emit changes of your assets with your transferables included. This is a websocket connection.
     * Your GET endpoint
     */
    async getAssetsStreamTransferablesRaw() {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/stream/transferables`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetsFromJSON)(jsonValue));
    }
    /**
     * This will emit changes of your assets with your transferables included. This is a websocket connection.
     * Your GET endpoint
     */
    async getAssetsStreamTransferables() {
        const response = await this.getAssetsStreamTransferablesRaw();
        return await response.value();
    }
    /**
     * *** IMPORTANT this stream will emit changes WITHOUT the transferables on a format. if you want transferables included please refer to /assets/stream/transferables
     * /assets/stream [GET]
     */
    async streamAssetsRaw() {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/assets/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.AssetsFromJSON)(jsonValue));
    }
    /**
     * *** IMPORTANT this stream will emit changes WITHOUT the transferables on a format. if you want transferables included please refer to /assets/stream/transferables
     * /assets/stream [GET]
     */
    async streamAssets() {
        const response = await this.streamAssetsRaw();
        return await response.value();
    }
}
exports.AssetsApi = AssetsApi;
