"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonsApi = void 0;
const runtime = __importStar(require("../runtime"));
const models_1 = require("../models");
/**
 *
 */
class PersonsApi extends runtime.BaseAPI {
    /**
     * This will update both the asset and the person reference, that will remove a person from an asset(only the references).  This will NOT remove the person. This will NOT remove the asset. This will only update the references so that they are disconnected from one another.
     * /persons/{person}/assets/delete/{asset} [POST]
     */
    async personDisassociateAssetRaw(requestParameters) {
        if (requestParameters.person === null || requestParameters.person === undefined) {
            throw new runtime.RequiredError('person', 'Required parameter requestParameters.person was null or undefined when calling personDisassociateAsset.');
        }
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset', 'Required parameter requestParameters.asset was null or undefined when calling personDisassociateAsset.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/persons/{person}/assets/delete/{asset}`.replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.VoidApiResponse(response);
    }
    /**
     * This will update both the asset and the person reference, that will remove a person from an asset(only the references).  This will NOT remove the person. This will NOT remove the asset. This will only update the references so that they are disconnected from one another.
     * /persons/{person}/assets/delete/{asset} [POST]
     */
    async personDisassociateAsset(requestParameters) {
        await this.personDisassociateAssetRaw(requestParameters);
    }
    /**
     * This will create a new person.
     * /persons/create [POST]
     */
    async personsCreateNewPersonRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/persons/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.SeededPersonToJSON)(requestParameters.seededPerson),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.PersonFromJSON)(jsonValue));
    }
    /**
     * This will create a new person.
     * /persons/create [POST]
     */
    async personsCreateNewPerson(requestParameters) {
        const response = await this.personsCreateNewPersonRaw(requestParameters);
        return await response.value();
    }
    /**
     * This will delete a specific person.
     * /persons/{person}/delete [POST]
     */
    async personsDeletePersonRaw(requestParameters) {
        if (requestParameters.person === null || requestParameters.person === undefined) {
            throw new runtime.RequiredError('person', 'Required parameter requestParameters.person was null or undefined when calling personsDeletePerson.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/persons/{person}/delete`.replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.VoidApiResponse(response);
    }
    /**
     * This will delete a specific person.
     * /persons/{person}/delete [POST]
     */
    async personsDeletePerson(requestParameters) {
        await this.personsDeletePersonRaw(requestParameters);
    }
    /**
     * This will get a snapshot of all of your people
     * /persons [GET]
     */
    async personsSnapshotRaw(requestParameters) {
        const queryParameters = {};
        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/persons`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.PersonsFromJSON)(jsonValue));
    }
    /**
     * This will get a snapshot of all of your people
     * /persons [GET]
     */
    async personsSnapshot(requestParameters) {
        const response = await this.personsSnapshotRaw(requestParameters);
        return await response.value();
    }
}
exports.PersonsApi = PersonsApi;
